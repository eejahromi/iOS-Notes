-Useful debugging techniques and strategies

Signals

SIGABRT
abnormal termination
syntax is correct, but logically incorrect.
usually means XCode terminated because the app tried to do something it shouldn't.

SIGSEGV (BAD_ACCESS)
Invalid memory access. Address exists but we don't have access to it.
SIGBUS (BAD_ACCESS)
Invalid memory access. Adress doesn't exist or accessor is invalid.

-enabling zombies
for BAD_ACCESS errors it is useful to enable zombies in the project target to get more info on where the error is happening.
Project target > Edit scheme > Diagnostics > check enable zombie objects

- “unrecognized selector” error, usually means we forgot to implement a method somewhere

-enabling thread sanitizer
Project target > Edit scheme > Run > Options > Enable thread sanitizer

Example for debugging
-check the signal if there is one given
-check the exception if there is one (i.e NSInvalidArgException)
-check the call stack for the methods that were called. (gray ones are system calls, black ones are our calls)
-check call stack registers if given. using lldb: di -s <register address> to get more info about the call.
(look for the ones that involve our code)

LLDB
(lldb)di -s <register address> // usually disassemble the first address that is a totally different number than the rest
(lldb) thread list // tells you which thread is this code run on, great for when dealing with threads
(lldb) rb . -s AppName // sets a breakpoint in every function of the app

(lldb)target modules list // a set of commands to inspect modules in the specified target

// prints the view hierarchy (text format of viewHierarchy button in toolbar)
(lldb)po [[[[UIApplication sharedApplication] delegate] window] recursiveDescription];


ADVANCED LLDB
-lldb from command line
(lldb)process attach -n "appName" -w // attach lldb to an app on iOS sim. Run this command and then start app in simulator.
// set a breakpoint when something happens without looking at the code
// in this case we break when a UILabel's text gets set to "Hi"
(lldb)rb UILabel.setText: -c '(BOOL)[$rdx containsString:@"Hi"]'

-lldb attach to a process on Device
$ ios-deploy -d -W -b path/to/foo.app

-breakpoints tips
General breakpoints
-use the navigator
CMD + backslash for adding/deleting breakpoints
-can group or share breakpoints
log statements: %B will print the method we're in at breakpoint, %H hit count of the method

Logging breakpoints
Edit breakpoint > conditions/actions/commands
Executing scripts

-Exception breakpoint 
(when we end up in main.m without useful info)
exception navigator > add exception point > add action
actions: 
po $eax (32 bit simulator) $rax (64 bit) $r0 (device)
bt (backtrace)

-Symbolic breakpoint
for ignoring cases like skipping iterations of loops and adding more action
also for stopping in a specific place in multiple files.
Example,
we can set a symbolic break point in every viewDidLoad: in every ViewController to find associated files with ViewControllers inside our running app

(say we want to break when a tableViewCell has the text "new Content" in it)
Symbol: -[UILabel setText:]
Condition: (BOOL)[$rdx containsString:@"cool"]

(we want to print the name of the class associated with a viewController as we navigate through app)
Symbol: -[UIViewController viewDidAppear:]
Condition: sizeof(void *) == 8 // only print for 64 bit
action: po [$rdi class] // print class name in register 1
* check automatically continue after

Sound on breakpoint
setup to make a sound when a line of code is executed
Edit Breakpoint > addAction > pick sound /check Automatically continue after evaluating


