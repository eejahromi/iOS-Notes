ios sdk layers

cocoa touch
media services
core services
core os

UIPickerView protocols
<UIPickerViewDataSource,UIPickerViewDelegate>
UIPickerViewDataSource
-How many components for the picker
-How many rows

if more than one component then
if (component == 0)
do something
else 
do something

UIPickerViewDelegate
-Title for each row
-Selection row response

UITableView <UITableViewDataSource,UItableViewDelegate>
How many rows
Row selection

deqeue cell with custom tableview cell
(with #import "CustomTableViewCell.h")
CustomTableViewCell *cell = (UITableViewCell *)[tableView deqeueReusableCellWithIdentifier:@"Cell"];

for enabling editing in a tableView use the method:
-(void)tableView:(UITableView *)tableView commitEditingStyle:

if you want to cusmize a cell you have to create a new file "CustomTableViewCell" for it and have the code in there.

setting the top edge in code
UIEdgeInsets contentInset = tableView.contentInset;
content.top = 20; // 20 points from the top
[tableView setContentInset:contentInset];

objective-c
NSLog() for printing to the screen
@"Hello" // @ before all string literals

no string data type, instead
NSString *message = @"Hello World"; // using a pointer
NSString is a class and message is an object name, object being "Hello World"


classes and objects
class is the blueprint for the house
object IS THE HOUSE

method/class operations in Objective-c vs java/C++

_height as an instance variable is actually 
self.height behind the scenes

calling a method inside a class
myObject.myMethod();

[myObject myMethod];

calling methods with arguments:
myObject.someMethod(arg);
[myObject someMethod:arg];

multiple arguments:
myObject.insert("Hello",11);
[myObject insertString: @"Hello" atIndex:11];

nested method calls:
[myObject someMethod:[anotherObject anotherMethod]];


allocating and instantiating a new class:
NSDate *myDate
myDate = [NSDate new];

NSDate *myDate = [[NSDate alloc]init];
Class *myObj = [[Class alloc]init];

initializing classes:
self = [super init];
    if (self) {
    // do stuff
    }

collections
nsarray, nsdictionary, nsset

arrays:
NSArray to add objects to it
// we initialize it by using initWithObjects:@"one",@"two",nil;
NSLog(@"second element:%@",myArray[1]);

// NSArray is immutable
//shorthand for NSArray
NSArray *quicker = @[@"apple",@"orange",@"banana"]; //no nil

IndexPath object has a property (row) that could points to a path in the array.
IndexPath *index;
NSString *title = index.path;

NSMutableArray *myArray = [[NSMutableArray alloc]initWithObjects:...

dictionary:
NSDictionary *states = 
[[NSDictionary alloc]initWithObjectsAndKeys:@"Arizona",@"AZ",
								@"California",@"CA",
                            	 @"Utah",@"UT",nil];
NSString *myState = @"CA";
        NSLog(@"%@ is for %@",myState,[states objectForKey:myState]);
        NSLog(@"%@ is for %@",myState,states[myState]);
        

NSMutableDictionary *states = ...

NSDictionary *quicker = @{ @"AZ" : @"Arizona", @"CA" : @"California" };

for-in loop:
for(NSString *name in listOfNames){
	// use name
}

-inheritance in objective-c is not that big of a deal
if you want to add a few methods to the NSString class to have more flexibility
	you donâ€™t need to add a subclass with a few added methods. you just use
	categories to add to the functionality of the existing class.

@interface ClassTOExtend (myCategoryName)
// add new methods

@end







